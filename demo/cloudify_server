#!/usr/bin/env ruby
# frozen_string_literal: true

REPL = true

require_relative "../loader"
require "timeout"

LOCATIONS = Option::Locations.map { |l| [l.name, "#{l.provider.display_name} #{l.display_name}"] }.to_h

def get_input(msg, default = nil)
  prompt = "#{msg}#{default.nil? ? "" : " [default: #{default}]"}: "
  input = ""

  while input.empty?
    print prompt
    input = gets.chomp
    input = default if input.empty? && !default.nil?
  end

  input
end

def select_option(msg, options, default = nil)
  puts "\n"
  options.each_with_index { |(key, name), index| puts "#{index + 1}. #{name}" }
  puts "\n"

  prompt = "#{msg}#{default.nil? ? "" : " [default: #{default}]"}: "
  selected = nil

  while selected.nil?
    print prompt
    option = gets.chomp
    option = if option.empty?
      default
    elsif option.to_i < 1
      puts "Plese enter a number between 1-#{options.count}#{default.nil? ? "" : " or leave empty for default"}"
    else
      option.to_i
    end

    selected = options.keys[option - 1] unless option.nil?
  end

  selected
end

unless Project[Config.minio_service_project_id]
  Project.create(name: "minio-project", provider: "hetzner") { _1.id = Config.minio_service_project_id }.tap { _1.associate_with_project(_1) }
end

unless Project[Config.postgres_service_project_id]
  Project.create(name: "pg-project", provider: "hetzner") { _1.id = Config.postgres_service_project_id }.tap { _1.associate_with_project(_1) }
end

hostname = get_input("Enter hostname or IP address")
location = select_option("Select provider and location", LOCATIONS, 1)
server_id = get_input("Enter Hetzner server ID")

puts "\n\nCloudifying '#{hostname}' server for '#{LOCATIONS[location]}' \n\n"

strand = Prog::Vm::HostNexus.assemble(hostname, location: location, provider: "hetzner", hetzner_server_identifier: server_id)

puts "Waiting public SSH keys\n\n"
until (ssh_key = strand.reload.subject.sshable.keys.map(&:public_key).first)
  sleep 2
end
puts "Add following public SSH key to '/root/.ssh/authorized_keys' on your machine\n\n"
puts ssh_key

print "\n\nPress enter after you add the above SSH key to your machine\n\n"
gets.chomp

begin
  Timeout.timeout(10 * 60) do
    puts "Waiting for server to be cloudified"
    previous_state = nil
    while (state = strand.reload.label) != "wait"
      if previous_state != state
        puts "#{Time.now} state: #{state}"
        previous_state = state
      end
      sleep 2
    end
  end
rescue Timeout::Error
  puts "\n\n"
  puts "Could not cloudify server in 10 minutes. Probably something went wrong."
  puts "Last state: #{strand.label}. Server ID for debug: #{strand.id}"
  puts "Please check your hostname/IP address and be sure that you added the correct public SSH key to your server."
  puts "You can ask for help on GitHub discussion page: https://github.com/ubicloud/ubicloud/discussions"
  exit 1
end

puts "\n\nYour server is cloudified now. You can create virtual machines at '#{location}' in the cloud dashboard."

puts "\n\nDownloading PostgreSQL OS image..."
download_image_strand = strand.reload.subject.download_boot_image("postgres-ubuntu-2204", ENV["PG_SAS_TOKEN"])
previous_state = nil
while download_image_strand.reload.exitval.nil?
  state = download_image_strand.reload.label
  if previous_state != state
    puts "#{Time.now} state: #{state}"
    previous_state = state
  end
  sleep 2
end

exit 1 unless get_input("Do you want to provision a MinIO cluster? (y/n)") == "y"

minio_strand = Prog::Minio::MinioClusterNexus.assemble(Config.minio_service_project_id, "minio-cluster", location, "pg-minio", 20, 1, 1, 1, "standard-2", Config.postgres_service_blob_storage_id)
puts "Waiting for minio cluster to be provisioned"
previous_state = nil
while (state = minio_strand.reload.label) != "wait"
  if previous_state != state
    puts "#{Time.now} state: #{state}"
    previous_state = state
  end
  sleep 2
end
